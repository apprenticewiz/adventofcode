#lang racket

(require racket/cmdline
         racket/port
         racket/system)

(define (usage progname)
  (displayln (string-append "usage: " progname " <input file>") (current-error-port))
  (exit 1))

(define (process content)
  (let* ((regexes
          (list #px"^(\\d+|\\w+) -> (\\w+)$"
                #px"NOT (\\d+|\\w+) -> (\\w+)"
                #px"(\\d+|\\w+) AND (\\d+|\\w+) -> (\\w+)"
                #px"(\\d+|\\w+) OR (\\d+|\\w+) -> (\\w+)"
                #px"(\\d+|\\w+) LSHIFT (\\d+) -> (\\w+)"
                #px"(\\d+|\\w+) RSHIFT (\\d+) -> (\\w+)"))
         (operations
           (foldl
             (lambda (line acc)
               (let ((op (cond ((regexp-match? (list-ref regexes 0) line)
                                  (let* ((caps (regexp-match (list-ref regexes 0) line))
                                         (dest (list-ref caps 2))
                                         (src (list-ref caps 1)))
                                    (list dest 'assign src)))
                               ((regexp-match? (list-ref regexes 1) line)
                                  (let* ((caps (regexp-match (list-ref regexes 1) line))
                                         (dest (list-ref caps 2))
                                         (src (list-ref caps 1)))
                                   (list dest 'not src)))
                               ((regexp-match? (list-ref regexes 2) line)
                                  (let* ((caps (regexp-match (list-ref regexes 2) line))
                                         (dest (list-ref caps 3))
                                         (src1 (list-ref caps 1))
                                         (src2 (list-ref caps 2)))
                                   (list dest 'and src1 src2)))
                               ((regexp-match? (list-ref regexes 3) line)
                                  (let* ((caps (regexp-match (list-ref regexes 3) line))
                                         (dest (list-ref caps 3))
                                         (src1 (list-ref caps 1))
                                         (src2 (list-ref caps 2)))
                                   (list dest 'or src1 src2)))
                               ((regexp-match? (list-ref regexes 4) line)
                                  (let* ((caps (regexp-match (list-ref regexes 4) line))
                                         (dest (list-ref caps 3))
                                         (src (list-ref caps 1))
                                         (amt (list-ref caps 2)))
                                   (list dest 'lshift src (string->number amt))))
                               ((regexp-match? (list-ref regexes 5) line)
                                  (let* ((caps (regexp-match (list-ref regexes 5) line))
                                         (dest (list-ref caps 3))
                                         (src (list-ref caps 1))
                                         (amt (list-ref caps 2)))
                                   (list dest 'rshift src (string->number amt)))))))
                 (hash-set acc (car op) (cdr op))))
             (make-immutable-hash)
             (string-split content "\n")))
         (a (car (evaluate operations (make-immutable-hash) "a")))
         (new-ops (hash-set operations "b" (list 'assign (number->string a)))))
    (car (evaluate new-ops (make-immutable-hash) "a"))))

(define (evaluate operations cache expr)
  (cond ((andmap char-numeric? (string->list expr))
           (list (string->number expr) cache))
        ((hash-has-key? cache expr)
           (list (hash-ref cache expr) cache))
        (#t
           (let* ((operation (hash-ref operations expr))
                  (operator (list-ref operation 0)))
             (case operator
               ('assign (let* ((src (list-ref operation 1))
                               (l (evaluate operations cache src))
                               (r (list-ref l 0))
                               (c (hash-set (list-ref l 1) src r)))
                          (list r (hash-set c expr r))))
               ('not (let* ((src (list-ref operation 1))
                            (l (evaluate operations cache src))
                            (a (list-ref l 0))
                            (c (hash-set (list-ref l 1) src a))
                            (r (bitwise-and (bitwise-not a) 65535)))
                          (list r (hash-set c expr r))))
               ('and (let* ((src1 (list-ref operation 1))
                            (src2 (list-ref operation 2))
                            (l1 (evaluate operations cache src1))
                            (a (list-ref l1 0))
                            (c1 (hash-set (list-ref l1 1) src1 a))
                            (l2 (evaluate operations c1 src2))
                            (b (list-ref l2 0))
                            (c2 (hash-set (list-ref l2 1) src2 b))
                            (r (bitwise-and (bitwise-and a b) 65535)))
                          (list r (hash-set c2 expr r))))
               ('or (let* ((src1 (list-ref operation 1))
                           (src2 (list-ref operation 2))
                           (l1 (evaluate operations cache src1))
                           (a (list-ref l1 0))
                           (c1 (hash-set (list-ref l1 1) src1 a))
                           (l2 (evaluate operations c1 src2))
                           (b (list-ref l2 0))
                           (c2 (hash-set (list-ref l2 1) src2 b))
                           (r (bitwise-and (bitwise-ior a b) 65535)))
                         (list r (hash-set c2 expr r))))
               ('lshift (let* ((src1 (list-ref operation 1))
                               (amt (list-ref operation 2))
                               (l (evaluate operations cache src1))
                               (a (list-ref l 0))
                               (c (hash-set (list-ref l 1) src1 a))
                               (r (bitwise-and (arithmetic-shift a amt) 65535)))
                             (list r (hash-set c expr r))))
               ('rshift (let* ((src1 (list-ref operation 1))
                               (amt (list-ref operation 2))
                               (l (evaluate operations cache src1))
                               (a (list-ref l 0))
                               (c (hash-set (list-ref l 1) src1 a))
                               (r (bitwise-and (arithmetic-shift a (- amt)) 65535)))
                             (list r (hash-set c expr r)))))))))

(define (main)
  (define progname (find-system-path 'run-file))
  (define args (current-command-line-arguments))
  (cond
    [(= (vector-length args) 1)
      (define filename (vector-ref args 0))
      (define content (file->string filename))
      (define result (process content))
      (printf "result = ~a\n" result)]
    [else (usage (path->string progname))]))

(main)
